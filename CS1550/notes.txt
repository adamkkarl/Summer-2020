5/21/2020
CPU
1. What is a process?
2. How does context switching happen?
3. How does scheduling happen?
4. Bugs due to processes sharing a CPU

process - a program that's running
  has memory files, registers, process id (pid)
  
Process Control Block (PCB)
  (linux: task control block)
  pointer to process memory
  process state (running, waiting, etc)
  program counter and CPU registers
  CPU scheduling info
  memory management info
  accounting info (CPU used, clock time elapsed, etc)
  I/O status info

Context switching
1. CPU stores registers in old PCB
2. CPU reads registers from new PCB
  instructions ~1e-9s  mem access ~1e-6s
  so context switching has significant overhead

Scheduling
process state - is processs ready to run? waiting for network packet?
new, ready (in queue), running, waiting (on I/O or event), terminated

Schedulers
Short-term scheduler (CPU scheduler)
  selects next process and allocates CPU
  invoked frequently (ms) - must be fast
Long-term scheduler
  selects process to bring to queue
  infrequent (sec/min) - can be slow
  controls degree of multiprograming (processes in memory)
Medium-term scheduling
  when too many processes fill memory
  *swap* some out to disk temporarily

Queueing diagram
-> ready queue -> CPU ->
  -> terminate
  -> I/O request -> I/O queue -> I/O -> ready queue
  -> time slice expires -> ready queue
  -> fork a child -> child executes -> ready queue
  -> wait for interrupt -> interrupt occur -> ready queue

5/26/2020
fork - system call that creates a process
child gets new PCB
  knows pid of parent and copy of all parent's registers
child gets copy of parent's memory

fork() writes eax register to return a value
  parent: fork() returns pid of child
  child: fork() returns 0

ret = fork();
if (ret>0) {...parent code...}
if (ret==0){...child code...}

copy_on_write - setting to avoid overhead from forking
  only copies parent memory to child process memory if necessary
  NO memory copy on fork
  useful since often child process is completely different
    (ex: command line -> java runtime)

Process Creation
parent processes create children processes, creating tree
process identifier (pid) - identifies and manages processes
Resource sharing options:
  -parent and child chare all resources
  -children share subset (code, data, heap) of parent resources
  -parent and child share no resorces
Execution options
  -parent and child concurrent
  -parent wait()'s until children terminate

busy waiting/spinning - executing a long loop of nothing
  for(int i=0; i<10000000000; i++)

Orphan Process
  child with terminated parent
  gets adopted by OS process (id=1)

Zombie Process
  terminated process with parent still running
  process stays alive until parent wait()'s for it
  Bad - will take up memory until parent collects or orphans it

Process Termination
  parent can abort() a child if needed

5/28/2020
ThreadTest.java
for(int i=0; i<3; i++) {
  pthread_create(&tid[i], &attr, runner, (void *)((long long) i));
}
  //thread - children share heap/code/global vars of parent

void *runner(void *param) {
  int i = ((int)param);
  printf("%d param = %d\n", (int)tid[i], i);
  sum[i] = 0;
  for (int j=1; j<=n; j++) 
    sum[i] += j;
  pthread_exit(0);
}

Multiprocessing Bugs

Bounded Buffer Problem
  Circle Queue
  Producer process - adds to queue, increments size
  Consumer process - removes from queue, decrements size
Problem: Race Conditions
updating memory is not atomic (uninterruptable)

When it works
x==3
P1	P2
R1<=x		load
R1=R1+1		change
R1=>x		store
	R3<=x	load
	R3=R3+1	change
	R3=>x	store
x==5

When it gets interrupted (BUG)
x==3
P1	P2
R1<=x		load
	R3<=x	load
	R3=R3+1	change
R1=R1+1		change
R1=>x		store
	R1=>x	store
x==4

1 thread at a time:
private synchronized void addSum (Integer sum)
  sums.add(sum);

Critical Regions
  used to procide *mutual exclusion* and help fix race conditions
4 conditions for mutual exclusion
  1. No 2 processes simultaneously in critical region
  2. No assumptions about the speeds or number of CPUs
  3. No process outside of critical region can block another process
  4. No process must wait forever to enter its critical region

Busy Waiting: Strict Alternation
Use shared variable (turn) to keep track of whose turn

